utils::globalVariables(c(":=", "year", "country", "trend_strength", "linearity", "curvature"))

#' Compute trend and shape features
#'
#' Calculates trend strength, linearity, and curvature using the `feasts` and `fabletools` packages functionality.
#'
#' @param wdi_data A data frame of the indicator data generated by \code{\link{get_wdi_data}}
#' @param index An optional character string specifying the indicator code
#' Defaults to `NULL`
#'
#' @returns A data frame with columns `country`, `trend_strength`, `linearity`, `curvature`, and `smoothness`.
#' @export
#'
#' @examples
#' pm_data <- get_wdi_data(indicator = "EN.ATM.PM25.MC.M3")
#'pm_trend_shape <- compute_trend_shape_features(pm_data)
compute_trend_shape_features <- function(wdi_data, index = NULL){
  # Identify the name of the variable in the wdi data that contains the country-year value as index
  if(is.null(index)) {
    index_var <- attr(wdi_data, "index_var")
    index = index_var[1]
  }

  # Check if 'country', 'year', and 'index' columns are present in the data set.
  # Proceed if all exist; otherwise, return the informative error message.
  cols <- c("country", "year", index)
  missing_cols <- cols[!cols %in% names(wdi_data)]
  if (length(missing_cols) > 0){
    stop(paste("The required column(s) are missing in the provided dataset:",
               paste(missing_cols, collapse = ", ")))
  }


  # filter valid countries and years where actual data were collected, ignoring the WDI defaults
  # using the `get_valid_data()` function
  invisible(utils::capture.output(
    valid_data <- get_valid_data(wdi_data)
  ))

  # calculate smoothness
  smoothness <- valid_data |>
    dplyr::arrange(country, year) |>
    dplyr::group_by(country) |>
    dplyr::mutate(
      diff = (.data[[index]] - dplyr::lag(.data[[index]])) /
        (year - dplyr::lag(year))
    ) |>
    dplyr::summarise(
      smoothness = stats::sd(diff, na.rm = TRUE),
      .groups = "drop"
    )

  # check if valid data has missing entries, if there are missing points, replace by linear interpolation, else return the valid data
  if(any(is.na(valid_data[[index]]))) {
    complete_data <- valid_data |>
      dplyr::group_by(country) |>
      dplyr::arrange(year) |>
      dplyr::mutate(!!index := stats::approx(
        x = year[!is.na(.data[[index]])], # take the non-missing years as x
        y = .data[[index]][!is.na(.data[[index]])], # take the non-missing values as y
        xout = year,
        rule = 2 # if the immediate nearest values are also NA, use the next available point for interpolation
      )$y) |>
      dplyr::ungroup()

    cat(
      "Note: The dataset '", deparse(substitute(wdi_data)),
      "' has missing values.\n Missing entries were replaced by linear interpolation."
    )
  } else {
    complete_data <- valid_data
  }

  # the features from the feasts package
  # convert the data to tsibble
  data_tsibble <- tsibble::as_tsibble(complete_data,
                                      index = year,
                                      key = country,
                                      regular = TRUE)

  trend_features <- data_tsibble |>
    fabletools::features(.data[[index]], feasts::feat_stl) |>
    dplyr::select(country, trend_strength, linearity, curvature)

  trend_shape_features <- trend_features |>
    dplyr::left_join(smoothness, by = "country")

  return(trend_shape_features)
}
