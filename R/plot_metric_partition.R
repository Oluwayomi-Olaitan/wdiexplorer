#' Plot of metric values partitioned by grouping variable
#'
#' Generates bars representing the metric value of each country, countries are partitioned by the levels of a specified variable.
#' The metric value of each country is represented by a coloured bar ordered in descending order, while a lighter-shaded rectangular bar beneath indicates the group-level average for the metric.
#' Countries in each group-level are represented by the same colour.
#'
#' @param metric_summary A data frame containing computed diagnostic metrics and the pre-defined grouping information,
#' generated by passing the output of any diagnostic metrics function to \code{\link{add_group_info}}
#' @param metric_var Character string specifying metric variable name in `metric_summary` to plot
#' @param group_var A grouping variable in the WDI data set (e.g., "region" or "income")
#'
#' @returns A `ggplot` object displaying the metric value of each country by a coloured bar ordered in descending order.
#' A lighter-shaded rectangular bar is displayed beneath the bars indicating their respective group-level average.
#' @export
#'
#' @examples
#' pm_diagnostic_metrics <- compute_diagnostic_indices(pm_data, group_var = "region")
#' pm_diagnostic_metrics_group <- add_group_info(metric_summary = pm_diagnostic_metrics,pm_data)
#' plot_metric_partition(metric_summary = pm_diagnostic_metrics_group,
#' metric_var = "sil_width", group_var = "region")
plot_metric_partition <- function(metric_summary, metric_var, group_var){
  group_metric <- metric_summary |>
    dplyr::group_by(.data[[group_var]]) |>
    dplyr::mutate(group_avg = mean(.data[[metric_var]])) |>
    dplyr::ungroup() |>
    # Re-order group_var by the group_avg
    dplyr::mutate(group = forcats::fct_reorder(.data[[group_var]], -.data$group_avg)) |>
    # Now create colours in the order of reordered groups
    dplyr::mutate(
      colour = scales::hue_pal()(length(levels(group)))[as.integer(group)],
      country_label = paste0("<span style='colour:", .data$colour, "'>", .data$country, "</span>")
    ) |>
    dplyr::group_by(group) |>
    dplyr::arrange(.data[[metric_var]], .by_group = TRUE) |>
    dplyr::mutate(country_label = forcats::fct_inorder(country_label)) |>
    dplyr::ungroup()

  # The plot
  P <- group_metric |>
    ggplot2::ggplot() +
    # Draw group average bars in the background
    ggplot2::geom_col(
      ggplot2::aes(x = .data$group_avg,
                   y = country_label, fill = group),
      width = 1, alpha = 0.25) +
    ggplot2::geom_col(
      ggplot2::aes(x = .data[[metric_var]],
                   y = country_label, fill = group),
      width = 0.75) +
    ggplot2::facet_grid(ggplot2::vars(group), scales = "free_y", space = "free_y", switch = "y") +
    ggplot2::labs(x = paste0("Metric Measure: ",metric_var), y = " " ) +
    ggplot2::theme(
      axis.text.y = ggtext::element_markdown(size = 5.6),
      axis.ticks.y = ggplot2::element_blank(),
      legend.position = "none",
      panel.spacing = grid::unit(0.05, "lines"),
      strip.text.y.left = ggplot2::element_text(hjust = 1, angle = 0),
      strip.background = ggplot2::element_rect(fill = "white"),
      strip.placement = "outside"
    )

  # converting the ggplot to a graphical object

  G <- ggplot2::ggplotGrob(P)

  stripl <- which(grepl('strip-l', G$layout$name))  #the strip names has been switch to the left, hence the reason for the strip-l

  # let's extract the default colour scheme used by geom_col
  # Build the ggplot to extract fill colours
  built <- ggplot2::ggplot_build(P)

  # Extract fill colours from the first layer (group_avg bars) and
  # adding the default fill colour to the panel_groups
  default_colours <- built$data[[1]] |>
    dplyr::select(.data$PANEL, .data$fill) |>
    dplyr::distinct()

  panel_groups <- built$layout$layout |>
    dplyr::select(.data$PANEL, .data$group)

  fill_colours <- panel_groups |>
    dplyr::left_join(default_colours, by = "PANEL")


  for (i in stripl){
    j <- which(grepl('rect', G$grobs[[i]]$grobs[[1]]$childrenOrder))
    k <- which(grepl('text', G$grobs[[i]]$grobs[[1]]$childrenOrder))
    grobtext <- G$grobs[[i]]$grobs[[1]]$children[[k]]$children[[1]]$label
    st <- match(gsub("\n", " ", grobtext), fill_colours$group)
    if (!is.na(st)){
      r <- which(grepl('text', G$grobs[[i]]$grobs[[1]]$children[[k]]$childrenOrder))
      G$grobs[[i]]$grobs[[1]]$children[[k]]$children[[r]]$gp$col <- fill_colours[st, "fill"]
    }
  }

  grid::grid.draw(G)
}
