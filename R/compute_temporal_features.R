#' Compute sequential temporal features
#'
#' Calculates number of crossing points, longest flat spot using the `feasts` package functionality and an additional time series feature - autocorrelation.
#'
#' @param wdi_data A data frame of the indicator data generated by \code{\link{get_wdi_data}}
#' @param index An optional character string specifying the indicator code
#' Defaults to `NULL`
#'
#' @returns A data frame with columns `country`, `crossing_points`, `flat_spot`, and `acf`.
#' @export
#'
#' @examples
#' pm_data <- get_wdi_data(indicator = "EN.ATM.PM25.MC.M3")
#' pm_temporal <- compute_temporal_features(pm_data)
compute_temporal_features <- function(wdi_data, index = NULL){

  # Identify the name of the variable in the wdi data that contains the country-year value as index
  if(is.null(index)) {
    index_var <- attr(wdi_data, "index_var")
    index = index_var[1]
  }

  # Check if 'country', 'year', and 'index' columns are present in the data set.
  # Proceed if all exist; otherwise, return the informative error message.
  cols <- c("country", "year", index)
  missing_cols <- cols[!cols %in% names(wdi_data)]
  if (length(missing_cols) > 0){
    stop(paste("The required column(s) are missing in the provided dataset:",
               paste(missing_cols, collapse = ", ")))
  }

  # filter valid countries and years where actual data were collected, ignoring the WDI defaults
  # using the `get_valid_data()` function
  invisible(utils::capture.output(
    valid_data <- get_valid_data(wdi_data)
  ))

  temporal_measures <- valid_data |>
    dplyr::group_by(country) |>
    dplyr::arrange(country, year) |> # arrange year in ascending order within countries
    dplyr::summarise(
      crossing_points = feasts::n_crossing_points(.data[[index]]),
      flat_spot = feasts::longest_flat_spot(.data[[index]]),
      acf = stats::cor(.data[[index]], dplyr::lag(.data[[index]]), use = "complete.obs")
    )

  return(temporal_measures)
}

